# -*- coding: utf-8 -*-

# This module contains a generic Metadata class implementation that
# can be used used by any python implementations of OSID forms.  Note
# that instances must be constructed with all necessary metadata.

from ...abstract_osid.osid import metadata as abc_osid_metadata
from .osid_errors import IllegalState, NullArgument

class Metadata(abc_osid_metadata.Metadata):
    """The Metadata interface defines a set of methods describing a the
    syntax and rules for creating and updating a data element inside an
    OsidForm.

    This interface provides a means to retrieve special restrictions
    placed upon data elements such as sizes and ranges that may vary
    from provider to provider or from object to object.

    """

    def __init__(self, element_id,
                       element_label,
                       instructions = '', 
                       required = None, 
                       value = None,
                       read_only = None, 
                       linked = None, 
                       syntax = None, 
                       array = None,
                       units = None, 
                       minimum_elements = None, 
                       maximum_elements = None, 
                       minimum_cardinal = None, 
                       maximum_cardinal = None, 
                       cardinal_set = [], 
                       coordinate_set = [], 
                       coordinate_types = [], 
                       axes_for_coordinate_type = None, 
                       minimum_coordinate_values = [], 
                       maximum_coordinate_values = [], 
                       minimum_currency = None, 
                       maximum_currency = None, 
                       currency_set = [], 
                       currency_types = [], 
                       minimum_date_time = None, 
                       maximum_date_time = None, 
                       date_time_set = [], 
                       date_time_resolution = None, 
                       calendar_types = [], 
                       time_types = [], 
                       minimum_decimal = None, 
                       maximum_decimal = None, 
                       decimal_set = [], 
                       decimal_scale = None, 
                       minimum_duration = None, 
                       maximum_duration = None, 
                       duration_set = [], 
                       duration_unit_types = [], 
                       minimum_distance = None, 
                       maximum_distance = None, 
                       distance_set = [], 
                       distance_resolution = None, 
                       heading_set = [], 
                       heading_types = [], 
                       axes_for_heading_type = None, 
                       minimum_heading_values = [], 
                       maximum_heading_values = [], 
                       minimum_integer = None, 
                       maximum_integer = None, 
                       integer_set = [], 
                       spatial_unit_set = [], 
                       patial_unit_record_types = [], 
                       minimum_speed = None, 
                       maximum_speed = None, 
                       speed_set = [], 
                       minimum_string_length = None, 
                       maximum_string_length = None, 
                       string_set = [], 
                       string_match_types = [], 
                       string_format = None, 
                       minimum_time = None, 
                       maximum_time = None, 
                       time_set = [], 
                       time_resolution = None, 
                       id_set = [], 
                       type_set = [], 
                       maximum_version = None, 
                       minimum_version = None, 
                       version_set = [], 
                       object_types = []):

        self._element_id = element_id
        self._element_label = element_label
        self._instructions = instructions
        self._required = required
        self._value = value # has_value boolean
        self._read_only = read_only
        self._linked = linked
        self._syntax = syntax
        self._array = array
        self._units = units
        self._minimum_elements = minimum_elements
        self._maximum_elements = maximum_elements
        self._minimum_cardinal = minimum_cardinal
        self._maximum_cardinal = maximum_cardinal
        self._cardinal_set = cardinal_set
        self._coordinate_set = coordinate_set
        self._coordinate_types = coordinate_types
        self._axes_for_coordinate_type = axes_for_coordinate_type # This may be algorithm
        self._minimum_coordinate_values = minimum_coordinate_values 
        self._maximum_coordinate_values = maximum_coordinate_values 
        self._minimum_currency = minimum_currency
        self._maximum_currency = maximum_currency
        self._currency_set = currency_set
        self._currency_types = currency_types
        self._minimum_date_time = minimum_date_time
        self._maximum_date_time = maximum_date_time
        self._date_time_set = date_time_set
        self._date_time_resolution = date_time_resolution
        self._calendar_types = calendar_types
        self._time_types = time_types
        self._minimum_decimal = minimum_decimal
        self._maximum_decimal = maximum_decimal
        self._decimal_set = decimal_set
        self._decimal_scale = decimal_scale
        self._minimum_duration = minimum_duration
        self._maximum_duration = maximum_duration
        self._duration_set = duration_set
        self._duration_unit_types = duration_unit_types
        self._minimum_distance = minimum_distance
        self._maximum_distance = maximum_distance
        self._distance_set = distance_set
        self._distance_resolution = distance_resolution
        self._heading_set = heading_set
        self._heading_types = heading_types
        self._axes_for_heading_type = axes_for_heading_type # This may be an algorithm
        self._minimum_heading_values = minimum_heading_values
        self._maximum_heading_values = maximum_heading_values
        self._minimum_integer = minimum_integer
        self._maximum_integer = maximum_integer
        self._integer_set = integer_set
        self._spatial_unit_set = spatial_unit_set
        self._patial_unit_record_types = patial_unit_record_types
        self._minimum_speed = minimum_speed
        self._maximum_speed = maximum_speed
        self._speed_set = speed_set
        self._minimum_string_length = minimum_string_length
        self._maximum_string_length = maximum_string_length
        self._string_set = string_set
        self._string_match_types = string_match_types
        self._string_format = string_format
        self._minimum_time = minimum_time
        self._maximum_time = maximum_time
        self._time_set = time_set
        self._time_resolution = time_resolution
        self._id_set = id_set
        self._type_set = type_set
        self._maximum_version = maximum_version
        self._minimum_version = minimum_version
        self._version_set = version_set
        self._object_types = object_types

    def get_element_id(self):
        """Gets a unique Id for the data element.

        return: (osid.id.Id) - an Id
        compliance: mandatory - This method must be implemented.

        """
        return self._element_id

    def get_element_label(self):
        """Gets a display label for the data element.

        return: (osid.locale.DisplayText) - a display label
        compliance: mandatory - This method must be implemented.

        """
        return self._element_label

    def get_instructions(self):
        """Gets instructions for updating this data.

        This is a human readable description of the data element or
        property that may include special instructions or caveats to the
        end-user above and beyond what this interface provides.

        return: (osid.locale.DisplayText) - instructions
        compliance: mandatory - This method must be implemented.

        """
        return self._instructions

    def is_required(self):
        """Tests if this data element is required for creating new objects.

        return: (boolean) - true if this data is required, false
                otherwise
        compliance: mandatory - This method must be implemented.

        """
        return self._required

    def has_value(self):
        """Tests if this data element has a set value.

        return: (boolean) - true if this data has been set, false
                otherwise
        compliance: mandatory - This method must be implemented.

        """
        return self._value

    def is_read_only(self):
        """Tests if this data can be updated.

        This may indicate the result of a pre-authorization but is not a
        guarantee that an authorization failure will not occur when the
        create or update transaction is issued.

        return: (boolean) - true if this data is not updatable, false
                otherwise
        compliance: mandatory - This method must be implemented.

        """
        return self._read_only

    def is_linked(self):
        """Tests if this data element is linked to other data in the
        object.

        Updating linked data should refresh all metadata and revalidate
        object elements.

        return: (boolean) - true if this element is linked, false if
                updates have no side effect
        compliance: mandatory - This method must be implemented.

        """
        return self._linked

    def get_syntax(self):
        """Gets the syntax of this data.

        return: (osid.Syntax) - an enumeration indicating the  type of
                value
        compliance: mandatory - This method must be implemented.

        """
        return self._syntax

    def is_array(self):
        """Tests if this data element is an array.

        return: (boolean) - true if this data is an array, false if a
                single element
        compliance: mandatory - This method must be implemented.

        """
        return self._array

    def get_units(self):
        """Gets the units of this data for display purposes ('lbs',
        'gills', 'furlongs').

        return: (osid.locale.DisplayText) - the display units of this
                data or an empty string if not applicable
        compliance: mandatory - This method must be implemented.

        """
        return self._units

    def get_minimum_elements(self):
        """In the case where an array or list of elements is specified in
        an OsidForm, this specifies the minimum number of elements that
        must be included.

        return: (cardinal) - the minimum elements or 1 if is_array() is
                false
        compliance: mandatory - This method must be implemented.

        """
        return self._minimum_elements

    def get_maximum_elements(self):
        """In the case where an array or list of elements is specified in
        an OsidForm, this specifies the maximum number of elements that
        must be included.

        return: (cardinal) - the maximum elements or 1 if is_array() is
                false
        compliance: mandatory - This method must be implemented.

        """
        return self._maximum_elements

    def get_minimum_cardinal(self):
        """Gets the minimum cardinal value.

        return: (cardinal) - the minimum cardinal
        raise:  IllegalState - syntax is not a CARDINAL
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['CARDINAL']:
            raise IllegalState()
        else:
            return self._minimum_cardinal

    def get_maximum_cardinal(self):
        """Gets the maximum cardinal value.

        return: (cardinal) - the maximum cardinal
        raise:  IllegalState - syntax is not a CARDINAL
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['CARDINAL']:
            raise IllegalState()
        else:
            return self._maximum_cardinal

    def get_cardinal_set(self):
        """Gets the set of acceptable cardinal values.

        return: (cardinal) - a set of cardinals or an empty array if not
                restricted
        raise:  IllegalState - syntax is not a CARDINAL
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['CARDINAL']:
            raise IllegalState()
        else:
            return self._cardinal_set

    def get_coordinate_set(self):
        """Gets the set of acceptable coordinate values.

        return: (osid.mapping.Coordinate) - a set of coordinates or an
                empty array if not restricted
        raise:  IllegalState - syntax is not a COORDINATE
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['COORDINATE']:
            raise IllegalState()
        else:
            return self._coordinate_set

    def get_coordinate_types(self):
        """Gets the set of acceptable coordinate types.

        return: (osid.type.Type) - the set of coordinate types
        raise:  IllegalState - syntax is not a COORDINATE or
                SPATIALUNIT
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['COORDINATE', 'SPATIALUNIT']:
            raise IllegalState()
        else:
            return self._coordinate_types

    def supports_coordinate_type(self, coordinate_type=None):
        """Tests if the given coordinate type is supported.

        arg:    coordinateType (osid.type.Type): a coordinate Type
        return: (boolean) - true if the type is supported, false
                otherwise
        raise:  IllegalState - syntax is not a COORDINATE
        raise:  NullArgument - coordinateType is null
        compliance: mandatory - This method must be implemented.

        """
        if not coordinate_type:
            raise NullArgument('no input Type provided')
        if self._syntax not in ['COORDINATE']:
            raise IllegalState('put more meaninful message here')

        result = False
        if self.get.coordinate_types != []:
            for t in self.get.coordinate_types:
                if (t.get_authority == coordinate_type.get_authority and
                    t.get_identifier_namespace == coordinate_type.get_identifier_namespace and
                    t.get_identifier == coordinate_type.get_identifier):
                    result = True
        return result

    def get_axes_for_coordinate_type(self, coordinate_type=None):
        """Gets the number of axes for a given supported coordinate type.

        arg:    coordinateType (osid.type.Type): a coordinate Type
        return: (cardinal) - the number of axes
        raise:  IllegalState - syntax is not a COORDINATE
        raise:  NullArgument - coordinateType is null
        raise:  UNSUPPORTED - supportsCoordinateType(coordinateType) is
                false
        compliance: mandatory - This method must be implemented.

        """
        pass

    def get_minimum_coordinate_values(self, coordinate_type=None):
        """Gets the minimum coordinate values given supported coordinate
        type.

        arg:    coordinateType (osid.type.Type): a coordinate Type
        return: (decimal) - the minimum coordinate values
        raise:  IllegalState - syntax is not a COORDINATE
        raise:  NullArgument - coordinateType is null
        raise:  UNSUPPORTED - supportsCoordinateType(coordinateType) is
                false
        compliance: mandatory - This method must be implemented.

        """
        pass

    def get_maximum_coordinate_values(self, coordinate_type=None):
        """Gets the maximum coordinate values given supported coordinate
        type.

        arg:    coordinateType (osid.type.Type): a coordinate Type
        return: (decimal) - the maximum coordinate values
        raise:  IllegalState - syntax is not a COORDINATE
        raise:  NullArgument - coordinateType is null
        raise:  UNSUPPORTED - supportsCoordinateType(coordinateType) is
                false
        compliance: mandatory - This method must be implemented.

        """
        pass

    def get_minimum_currency(self):
        """Gets the minimum currency value.

        return: (osid.financials.Currency) - the minimum currency
        raise:  IllegalState - syntax is not a CURRENCY
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['CURRENCY']:
            raise IllegalState()
        else:
            return self._minimum_currency

    def get_maximum_currency(self):
        """Gets the maximum currency value.

        return: (osid.financials.Currency) - the maximum currency
        raise:  IllegalState - syntax is not a CURRENCY
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['CURRENCY']:
            raise IllegalState()
        else:
            return self._maximum_currency

    def get_currency_set(self):
        """Gets the set of acceptable currency values.

        return: (osid.financials.Currency) - a set of currencies or an
                empty array if not restricted
        raise:  IllegalState - syntax is not a CURRENCY
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['CURRENCY']:
            raise IllegalState()
        else:
            return self._currency_set

    def get_currency_types(self):
        """Gets the set of acceptable currency types.

        return: (osid.type.Type) - the set of currency types
        raise:  IllegalState - syntax is not a CURRENCY
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['CURRENCY']:
            raise IllegalState()
        else:
            return self._currency_types

    def supports_currency_type(self, currency_type=None):
        """Tests if the given currency type is supported.

        arg:    currencyType (osid.type.Type): a currency Type
        return: (boolean) - true if the type is supported, false
                otherwise
        raise:  IllegalState - syntax is not a CURRENCY
        raise:  NullArgument - currencyType is null
        compliance: mandatory - This method must be implemented.

        """
        if not currency_type:
            raise NullArgument('no input Type provided')
        if self._syntax not in ['CURRENCY']:
            raise IllegalState('put more meaninful message here')

        result = False
        if self.get.currency_types != []:
            for t in self.get.currency_types:
                if (t.get_authority == currency_type.get_authority and
                    t.get_identifier_namespace == currency_type.get_identifier_namespace and
                    t.get_identifier == currency_type.get_identifier):
                    result = True
        return result

    def get_minimum_date_time(self):
        """Gets the minimum date time value.

        return: (osid.calendaring.DateTime) - the minimum value
        raise:  IllegalState - syntax is not a DATETIME
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DATETIME']:
            raise IllegalState()
        else:
            return self._minimum_date_time

    def get_maximum_date_time(self):
        """Gets the maximum date time value.

        return: (osid.calendaring.DateTime) - the maximum value
        raise:  IllegalState - syntax is not a DATETIME
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DATETIME']:
            raise IllegalState()
        else:
            return self._maximum_date_time

    def get_date_time_set(self):
        """Gets the set of acceptable date time values.

        return: (osid.calendaring.DateTime) - a set of values or an
                empty array if not restricted
        raise:  IllegalState - syntax is not a DATETIME
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DATETIME']:
            raise IllegalState()
        else:
            return self._date_time_set

    def get_date_time_resolution(self):
        """Gets the smallest resolution of the date time value.

        return: (osid.calendaring.DateTimeResolution) - the resolution
        raise:  IllegalState - syntax is not a DATETIME, DURATION , or
                TIME
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DATETIME,', 'DURATION', 'TIME']:
            raise IllegalState()
        else:
            return self._date_time_resolution

    def get_calendar_types(self):
        """Gets the set of acceptable calendar types.

        return: (osid.type.Type) - the set of calendar types
        raise:  IllegalState - syntax is not a DATETIME or DURATION
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DATETIME', 'DURATION']:
            raise IllegalState()
        else:
            return self._calendar_types

    def supports_calendar_type(self, calendar_type=None):
        """Tests if the given calendar type is supported.

        arg:    calendarType (osid.type.Type): a calendar Type
        return: (boolean) - true if the type is supported, false
                otherwise
        raise:  IllegalState - syntax is not a DATETIME or DURATION
        raise:  NullArgument - calendarType is null
        compliance: mandatory - This method must be implemented.

        """
        if not calendar_type:
            raise NullArgument('no input Type provided')
        if self._syntax not in ['DATETIME', 'DURATION']:
            raise IllegalState('put more meaninful message here')

        result = False
        if self.get.calendar_types != []:
            for t in self.get.calendar_types:
                if (t.get_authority == calendar_type.get_authority and
                    t.get_identifier_namespace == calendar_type.get_identifier_namespace and
                    t.get_identifier == calendar_type.get_identifier):
                    result = True
        return result

    def get_time_types(self):
        """Gets the set of acceptable time types.

        return: (osid.type.Type) - a set of time types or an empty array
                if not restricted
        raise:  IllegalState - syntax is not a DATETIME, DURATION, or
                TIME
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DATETIME,', 'DURATION,', 'TIME']:
            raise IllegalState()
        else:
            return self._time_types

    def supports_time_type(self, time_type=None):
        """Tests if the given time type is supported.

        arg:    timeType (osid.type.Type): a time Type
        return: (boolean) - true if the type is supported, false
                otherwise
        raise:  IllegalState - syntax is not a DATETIME, DURATION, or
                TIME
        raise:  NullArgument - timeType is null
        compliance: mandatory - This method must be implemented.

        """
        if not time_type:
            raise NullArgument('no input Type provided')
        if self._syntax not in ['DATETIME,', 'DURATION,', 'TIME']:
            raise IllegalState('put more meaninful message here')

        result = False
        if self.get.time_types != []:
            for t in self.get.time_types:
                if (t.get_authority == time_type.get_authority and
                    t.get_identifier_namespace == time_type.get_identifier_namespace and
                    t.get_identifier == time_type.get_identifier):
                    result = True
        return result

    def get_minimum_decimal(self):
        """Gets the minimum decimal value.

        return: (decimal) - the minimum decimal
        raise:  IllegalState - syntax is not a DECIMAL
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DECIMAL']:
            raise IllegalState()
        else:
            return self._minimum_decimal

    def get_maximum_decimal(self):
        """Gets the maximum decimal value.

        return: (decimal) - the maximum decimal
        raise:  IllegalState - syntax is not a DECIMAL
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DECIMAL']:
            raise IllegalState()
        else:
            return self._maximum_decimal

    def get_decimal_set(self):
        """Gets the set of acceptable decimal values.

        return: (decimal) - a set of decimals or an empty array if not
                restricted
        raise:  IllegalState - syntax is not a DECIMAL
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DECIMAL']:
            raise IllegalState()
        else:
            return self._decimal_set

    def get_decimal_scale(self):
        """Gets the number of digits to the right of the decimal point.

        return: (cardinal) - the scale
        raise:  IllegalState - syntax is not a DECIMAL
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DECIMAL']:
            raise IllegalState()
        else:
            return self._decimal_scale

    def get_minimum_distance(self):
        """Gets the minimum distance value.

        return: (osid.mapping.Distance) - the minimum value
        raise:  IllegalState - syntax is not a DISTANCE
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DISTANCE']:
            raise IllegalState()
        else:
            return self._minimum_distance

    def get_maximum_distance(self):
        """Gets the maximum distance value.

        return: (osid.mapping.Distance) - the maximum value
        raise:  IllegalState - syntax is not a DISTANCE
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DISTANCE']:
            raise IllegalState()
        else:
            return self._maximum_distance

    def get_distance_set(self):
        """Gets the set of acceptable distance values.

        return: (osid.mapping.Distance) - a set of values or an empty
                array if not restricted
        raise:  IllegalState - syntax is not a DISTANCE
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DISTANCE']:
            raise IllegalState()
        else:
            return self._distance_set

    def get_distance_resolution(self):
        """Gets the smallest resolution of the distance value.

        return: (osid.mapping.DistanceResolution) - the resolution
        raise:  IllegalState - syntax is not a DISTANCE
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DISTANCE']:
            raise IllegalState()
        else:
            return self._distance_resolution

    def get_minimum_duration(self):
        """Gets the minimum duration.

        return: (osid.calendaring.Duration) - the minimum duration
        raise:  IllegalState - syntax is not a DURATION
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DURATION']:
            raise IllegalState()
        else:
            return self._minimum_duration

    def get_maximum_duration(self):
        """Gets the maximum duration.

        return: (osid.calendaring.Duration) - the maximum duration
        raise:  IllegalState - syntax is not a DURATION
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DURATION']:
            raise IllegalState()
        else:
            return self._maximum_duration

    def get_duration_set(self):
        """Gets the set of acceptable duration values.

        return: (osid.calendaring.Duration) - a set of durations or an
                empty array if not restricted
        raise:  IllegalState - syntax is not a DURATION
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['DURATION']:
            raise IllegalState()
        else:
            return self._duration_set

    def get_heading_set(self):
        """Gets the set of acceptable heading values.

        return: (osid.mapping.Heading) - the set of heading
        raise:  IllegalState - syntax is not a HEADING
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['HEADING']:
            raise IllegalState()
        else:
            return self._heading_set

    def get_heading_types(self):
        """Gets the set of acceptable heading types.

        return: (osid.type.Type) - a set of heading types or an empty
                array if not restricted
        raise:  IllegalState - syntax is not a HEADING
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['HEADING']:
            raise IllegalState()
        else:
            return self._heading_types

    def supports_heading_type(self, heading_type=None):
        """Tests if the given heading type is supported.

        arg:    headingType (osid.type.Type): a heading Type
        return: (boolean) - true if the type is supported, false
                otherwise
        raise:  IllegalState - syntax is not a HEADING
        raise:  NullArgument - headingType is null
        compliance: mandatory - This method must be implemented.

        """
        if not heading_type:
            raise NullArgument('no input Type provided')
        if self._syntax not in ['HEADING']:
            raise IllegalState('put more meaninful message here')

        result = False
        if self.get.heading_types != []:
            for t in self.get.heading_types:
                if (t.get_authority == heading_type.get_authority and
                    t.get_identifier_namespace == heading_type.get_identifier_namespace and
                    t.get_identifier == heading_type.get_identifier):
                    result = True
        return result

    def get_axes_for_heading_type(self, heading_type=None):
        """Gets the number of axes for a given supported heading type.

        arg:    headingType (osid.type.Type): a heading Type
        return: (cardinal) - the number of axes
        raise:  IllegalState - syntax is not a HEADING
        raise:  NullArgument - headingType is null
        raise:  UNSUPPORTED - supportsHeadingType(headingType) is false
        compliance: mandatory - This method must be implemented.

        """
        pass

    def get_minimum_heading_values(self, heading_type=None):
        """Gets the minimum heading values given supported heading type.

        arg:    headingType (osid.type.Type): a heading Type
        return: (decimal) - the minimum heading values
        raise:  IllegalState - syntax is not a HEADING
        raise:  NullArgument - headingType is null
        raise:  UNSUPPORTED - supportsHeadingType(headingType) is false
        compliance: mandatory - This method must be implemented.

        """
        pass

    def get_maximum_heading_values(self, heading_type=None):
        """Gets the maximum heading values given supported heading type.

        arg:    headingType (osid.type.Type): a heading Type
        return: (decimal) - the maximum heading values
        raise:  IllegalState - syntax is not a HEADING
        raise:  NullArgument - headingType is null
        raise:  UNSUPPORTED - supportsHeadingType(headingType) is false
        compliance: mandatory - This method must be implemented.

        """
        pass

    def get_id_set(self):
        """Gets the set of acceptable Ids.

        return: (osid.id.Id) - a set of Ids or an empty array if not
                restricted
        raise:  IllegalState - syntax is not an ID
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['ID']:
            raise IllegalState()
        else:
            return self._id_set

    def get_minimum_integer(self):
        """Gets the minimum integer value.

        return: (integer) - the minimum value
        raise:  IllegalState - syntax is not an INTEGER
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['INTEGER']:
            raise IllegalState()
        else:
            return self._minimum_integer

    def get_maximum_integer(self):
        """Gets the maximum integer value.

        return: (integer) - the maximum value
        raise:  IllegalState - syntax is not an INTEGER
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['INTEGER']:
            raise IllegalState()
        else:
            return self._maximum_integer

    def get_integer_set(self):
        """Gets the set of acceptable integer values.

        return: (integer) - a set of values or an empty array if not
                restricted
        raise:  IllegalState - syntax is not an INTEGER
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['INTEGER']:
            raise IllegalState()
        else:
            return self._integer_set

    def get_object_types(self):
        """Gets the set of acceptable Types for an arbitrary object.

        return: (osid.type.Type) - a set of Types or an empty array if
                not restricted
        raise:  IllegalState - syntax is not an OBJECT
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['OBJECT']:
            raise IllegalState()
        else:
            return self._object_types

    def supports_object_type(self, object_type=None):
        """Tests if the given object type is supported.

        arg:    objectType (osid.type.Type): an object Type
        return: (boolean) - true if the type is supported, false
                otherwise
        raise:  IllegalState - syntax is not an OBJECT
        raise:  NullArgument - objectType is null
        compliance: mandatory - This method must be implemented.

        """
        if not object_type:
            raise NullArgument('no input Type provided')
        if self._syntax not in ['OBJECT']:
            raise IllegalState('put more meaninful message here')

        result = False
        if self.get.object_types != []:
            for t in self.get.object_types:
                if (t.get_authority == object_type.get_authority and
                    t.get_identifier_namespace == object_type.get_identifier_namespace and
                    t.get_identifier == object_type.get_identifier):
                    result = True
        return result

    def get_spatial_unit_set(self):
        """Gets the set of acceptable spatial unit values.

        return: (osid.mapping.SpatialUnit) - a set of spatial units or
                an empty array if not restricted
        raise:  IllegalState - syntax is not a SPATIALUNIT
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['SPATIALUNIT']:
            raise IllegalState()
        else:
            return self._spatial_unit_set

    def get_spatial_unit_record_types(self):
        """Gets the set of acceptable spatial unit record types.

        return: (osid.type.Type) - the set of spatial unit types
        raise:  IllegalState - syntax is not SPATIALUNIT
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['SPATIALUNIT']:
            raise IllegalState()
        else:
            return self._spatial_unit_record_types

    def supports_spatial_unit_record_type(self, spatial_unit_record_type=None):
        """Tests if the given spatial unit record type is supported.

        arg:    spatialUnitRecordType (osid.type.Type): a spatial unit
                record Type
        return: (boolean) - true if the type is supported, false
                otherwise
        raise:  IllegalState - syntax is not an SPATIALUNIT
        raise:  NullArgument - spatialUnitRecordType is null
        compliance: mandatory - This method must be implemented.

        """
        if not spatial_unit_record_type:
            raise NullArgument('no input Type provided')
        if self._syntax not in ['SPATIALUNIT']:
            raise IllegalState('put more meaninful message here')

        result = False
        if self.get.spatial_unit_record_types != []:
            for t in self.get.spatial_unit_record_types:
                if (t.get_authority == spatial_unit_record_type.get_authority and
                    t.get_identifier_namespace == spatial_unit_record_type.get_identifier_namespace and
                    t.get_identifier == spatial_unit_record_type.get_identifier):
                    result = True
        return result

    def get_minimum_speed(self):
        """Gets the minimum speed value.

        return: (osid.mapping.Speed) - the minimum speed
        raise:  IllegalState - syntax is not a SPEED
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['SPEED']:
            raise IllegalState()
        else:
            return self._minimum_speed

    def get_maximum_speed(self):
        """Gets the maximum speed value.

        return: (osid.mapping.Speed) - the maximum speed
        raise:  IllegalState - syntax is not a SPEED
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['SPEED']:
            raise IllegalState()
        else:
            return self._maximum_speed

    def get_speed_set(self):
        """Gets the set of acceptable speed values.

        return: (osid.mapping.Speed) - a set of speeds or an empty array
                if not restricted
        raise:  IllegalState - syntax is not a SPEED
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['SPEED']:
            raise IllegalState()
        else:
            return self._speed_set

    def get_minimum_string_length(self):
        """Gets the minimum string length.

        return: (cardinal) - the minimum string length
        raise:  IllegalState - syntax is not a STRING
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['STRING']:
            raise IllegalState()
        else:
            return self._minimum_string_length

    def get_maximum_string_length(self):
        """Gets the maximum string length.

        return: (cardinal) - the maximum string length
        raise:  IllegalState - syntax is not a STRING
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['STRING']:
            raise IllegalState()
        else:
            return self._maximum_string_length

    def get_string_set(self):
        """Gets the set of acceptable string values.

        return: (string) - a set of strings or an empty array if not
                restricted
        raise:  IllegalState - syntax is not a STRING
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['STRING']:
            raise IllegalState()
        else:
            return self._string_set

    def get_string_match_types(self):
        """Gets the set of valid string match types for use in validating a
        string.

        If the string match type indicates a regular expression then
        get_string_expression() returns a regular expression.

        return: (osid.type.Type) - the set of string match types
        raise:  IllegalState - syntax is not a STRING
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['STRING']:
            raise IllegalState()
        else:
            return self._string_match_types

    def supports_string_match_type(self, string_match_type=None):
        """Tests if the given string match type is supported.

        arg:    stringMatchType (osid.type.Type): a string match type
        return: (boolean) - true if the given string match type Is
                supported, false otherwise
        raise:  IllegalState - syntax is not a STRING
        raise:  NullArgument - stringMatchType is null
        compliance: mandatory - This method must be implemented.

        """
        if not string_match_type:
            raise NullArgument('no input Type provided')
        if self._syntax not in ['STRING']:
            raise IllegalState('put more meaninful message here')

        result = False
        if self.get.string_match_types != []:
            for t in self.get.string_match_types:
                if (t.get_authority == string_match_type.get_authority and
                    t.get_identifier_namespace == string_match_type.get_identifier_namespace and
                    t.get_identifier == string_match_type.get_identifier):
                    result = True
        return result

    def get_string_expression(self, string_match_type=None):
        """Gets the regular expression of an acceptable string for the
        given string match type.

        arg:    stringMatchType (osid.type.Type): a string match type
        return: (string) - the regular expression
        raise:  NullArgument - stringMatchType is null
        raise:  IllegalState - syntax is not a STRING
        raise:  UNSUPPORTED - supportsStringMatchType(stringMatchType )
                is false
        compliance: mandatory - This method must be implemented.

        """
        pass

    def get_string_format_types(self):
        """Gets the set of valid string formats.

        return: (osid.type.Type) - the set of valid text format types
        raise:  IllegalState - syntax is not a STRING
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['STRING']:
            raise IllegalState()
        else:
            return self._string_format_types

    def get_minimum_time(self):
        """Gets the minimum time value.

        return: (osid.calendaring.Time) - the minimum time
        raise:  IllegalState - syntax is not a TIME
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['TIME']:
            raise IllegalState()
        else:
            return self._minimum_time

    def get_maximum_time(self):
        """Gets the maximum time value.

        return: (osid.calendaring.Time) - the maximum time
        raise:  IllegalState - syntax is not a TIME
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['TIME']:
            raise IllegalState()
        else:
            return self._maximum_time

    def get_time_set(self):
        """Gets the set of acceptable time values.

        return: (osid.calendaring.Time) - a set of times or an empty
                array if not restricted
        raise:  IllegalState - syntax is not a TIME
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['TIME']:
            raise IllegalState()
        else:
            return self._time_set

    def get_type_set(self):
        """Gets the set of acceptable Types.

        return: (osid.type.Type) - a set of Types or an empty array if
                not restricted
        raise:  IllegalState - syntax is not a TYPE
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['TYPE']:
            raise IllegalState()
        else:
            return self._type_set

    def get_minimum_version(self):
        """Gets the minumim acceptable Version.

        return: (osid.installation.Version) - the minumim Version
        raise:  IllegalState - syntax is not a VERSION
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['VERSION']:
            raise IllegalState()
        else:
            return self._minimum_version

    def get_maximum_version(self):
        """Gets the maximum acceptable Version.

        return: (osid.installation.Version) - the maximum Version
        raise:  IllegalState - syntax is not a VERSION
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['VERSION']:
            raise IllegalState()
        else:
            return self._maximum_version

    def get_version_set(self):
        """Gets the set of acceptable Versions.

        return: (osid.installation.Version) - a set of Versions or an
                empty array if not restricted
        raise:  IllegalState - syntax is not a VERSION
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['VERSION']:
            raise IllegalState()
        else:
            return self._version_set

    def get_version_types(self):
        """Gets the set of acceptable version types.

        return: (osid.type.Type) - the set of version types
        raise:  IllegalState - syntax is not a VERSION
        compliance: mandatory - This method must be implemented.

        """
        if self._syntax not in ['VERSION']:
            raise IllegalState()
        else:
            return self._version_types

    def supports_version_type(self, version_type=None):
        """Tests if the given version type is supported.

        arg:    versionType (osid.type.Type): a version Type
        return: (boolean) - true if the type is supported, false
                otherwise
        raise:  IllegalState - syntax is not a VERSION
        raise:  NullArgument - versionType is null
        compliance: mandatory - This method must be implemented.

        """
        if not version_type:
            raise NullArgument('no input Type provided')
        if self._syntax not in ['VERSION']:
            raise IllegalState('put more meaninful message here')

        result = False
        if self.get.version_types != []:
            for t in self.get.version_types:
                if (t.get_authority == version_type.get_authority and
                    t.get_identifier_namespace == version_type.get_identifier_namespace and
                    t.get_identifier == version_type.get_identifier):
                    result = True
        return result


